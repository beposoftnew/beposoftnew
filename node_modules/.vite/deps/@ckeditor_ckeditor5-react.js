import {
  require_prop_types
} from "./chunk-MRVVLVEZ.js";
import "./chunk-T5TDCSU7.js";
import {
  init_src,
  src_exports
} from "./chunk-6EA7633W.js";
import "./chunk-SWBFGANQ.js";
import "./chunk-OX2NI5XB.js";
import "./chunk-SIFGPYD7.js";
import "./chunk-JABHAMWL.js";
import {
  require_react
} from "./chunk-I773Y2XN.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-LK32TJAX.js";

// node_modules/@ckeditor/ckeditor5-react/dist/index.js
var require_dist = __commonJS({
  "node_modules/@ckeditor/ckeditor5-react/dist/index.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(require_react(), require_prop_types(), (init_src(), __toCommonJS(src_exports))) : "function" == typeof define && define.amd ? define(["react", "prop-types", "@ckeditor/ckeditor5-watchdog"], e) : "object" == typeof exports ? exports.CKEditor = e(require_react(), require_prop_types(), (init_src(), __toCommonJS(src_exports))) : t.CKEditor = e(t.react, t["prop-types"], t["@ckeditor/ckeditor5-watchdog"]);
    }(self, (t, e, o) => (() => {
      "use strict";
      var r = { 546: (t2) => {
        t2.exports = o;
      }, 949: (t2) => {
        t2.exports = e;
      }, 155: (e2) => {
        e2.exports = t;
      } }, i = {};
      function n(t2) {
        var e2 = i[t2];
        if (void 0 !== e2) return e2.exports;
        var o2 = i[t2] = { exports: {} };
        return r[t2](o2, o2.exports, n), o2.exports;
      }
      n.n = (t2) => {
        var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
        return n.d(e2, { a: e2 }), e2;
      }, n.d = (t2, e2) => {
        for (var o2 in e2) n.o(e2, o2) && !n.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: e2[o2] });
      }, n.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), n.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var a = {};
      return (() => {
        n.r(a), n.d(a, { CKEditor: () => u, CKEditorContext: () => c, useMultiRootEditor: () => f });
        var t2 = n(155), e2 = n.n(t2), o2 = n(949), r2 = n.n(o2);
        const i2 = new Array(256).fill("").map((t3, e3) => ("0" + e3.toString(16)).slice(-2));
        var s = n(546);
        const d = e2().createContext("contextWatchdog");
        class c extends e2().Component {
          constructor(t3, e3) {
            super(t3, e3), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);
          }
          shouldComponentUpdate(t3) {
            return this._shouldComponentUpdate(t3);
          }
          async _shouldComponentUpdate(t3) {
            return t3.id !== this.props.id && (this.contextWatchdog && await this.contextWatchdog.destroy(), await this._initializeContextWatchdog(t3.config)), t3.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(t3.config), true) : this.props.children !== t3.children;
          }
          render() {
            return e2().createElement(d.Provider, { value: this.contextWatchdog }, this.props.children);
          }
          componentWillUnmount() {
            this._destroyContext();
          }
          async _initializeContextWatchdog(t3) {
            this.contextWatchdog = new s.ContextWatchdog(this.props.context, this.props.watchdogConfig), this.contextWatchdog.on("error", (t4, e3) => {
              this.props.onError(e3.error, { phase: "runtime", willContextRestart: e3.causesRestart });
            }), this.contextWatchdog.on("stateChange", () => {
              "ready" === this.contextWatchdog.state && this.props.onReady && this.props.onReady(this.contextWatchdog.context);
            }), await this.contextWatchdog.create(t3).catch((t4) => {
              this.props.onError(t4, { phase: "initialization", willContextRestart: false });
            });
          }
          async _destroyContext() {
            this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);
          }
        }
        c.defaultProps = { isLayoutReady: true, onError: (t3, e3) => console.error(t3, e3) }, c.propTypes = { id: r2().string, isLayoutReady: r2().bool, context: r2().func, watchdogConfig: r2().object, config: r2().object, onReady: r2().func, onError: r2().func };
        const h = "Lock from React integration (@ckeditor/ckeditor5-react)";
        class u extends e2().Component {
          constructor(t3) {
            super(t3), this.editorDestructionInProgress = null, this.domContainer = e2().createRef(), this.watchdog = null;
            const { CKEDITOR_VERSION: o3 } = window;
            if (o3) {
              const [t4] = o3.split(".").map(Number);
              t4 < 37 && console.warn("The <CKEditor> component requires using CKEditor 5 in version 37 or higher.");
            } else console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
          }
          get editor() {
            return this.props.disableWatchdog ? this.instance : this.watchdog ? this.watchdog.editor : null;
          }
          shouldComponentUpdate(t3) {
            return !!this.editor && (t3.id !== this.props.id || (t3.disableWatchdog !== this.props.disableWatchdog || (this._shouldUpdateEditor(t3) && this.editor.data.set(t3.data), "disabled" in t3 && (t3.disabled ? this.editor.enableReadOnlyMode(h) : this.editor.disableReadOnlyMode(h)), false)));
          }
          async componentDidMount() {
            await this._initializeEditor();
          }
          async componentDidUpdate() {
            await this._destroyEditor(), await this._initializeEditor();
          }
          async componentWillUnmount() {
            await this._destroyEditor();
          }
          render() {
            return e2().createElement("div", { ref: this.domContainer });
          }
          async _initializeEditor() {
            await this.editorDestructionInProgress, this.props.disableWatchdog ? this.instance = await this._createEditor(this.domContainer.current, this._getConfig()) : this.watchdog || (this.context instanceof s.ContextWatchdog ? this.watchdog = new l(this.context) : this.watchdog = new u._EditorWatchdog(this.props.editor, this.props.watchdogConfig), this.watchdog.setCreator((t3, e3) => this._createEditor(t3, e3)), this.watchdog.on("error", (t3, { error: e3, causesRestart: o3 }) => {
              (this.props.onError || console.error)(e3, { phase: "runtime", willEditorRestart: o3 });
            }), await this.watchdog.create(this.domContainer.current, this._getConfig()).catch((t3) => {
              (this.props.onError || console.error)(t3, { phase: "initialization", willEditorRestart: false });
            }));
          }
          _createEditor(t3, e3) {
            return this.props.editor.create(t3, e3).then((t4) => {
              "disabled" in this.props && this.props.disabled && t4.enableReadOnlyMode(h);
              const e4 = t4.model.document, o3 = t4.editing.view.document;
              return e4.on("change:data", (e5) => {
                this.props.onChange && this.props.onChange(e5, t4);
              }), o3.on("focus", (e5) => {
                this.props.onFocus && this.props.onFocus(e5, t4);
              }), o3.on("blur", (e5) => {
                this.props.onBlur && this.props.onBlur(e5, t4);
              }), setTimeout(() => {
                this.props.onReady && this.props.onReady(t4);
              }), t4;
            });
          }
          async _destroyEditor() {
            this.editorDestructionInProgress = new Promise((t3) => {
              setTimeout(async () => this.watchdog ? (await this.watchdog.destroy(), this.watchdog = null, t3()) : this.instance ? (await this.instance.destroy(), this.instance = null, t3()) : void t3());
            });
          }
          _shouldUpdateEditor(t3) {
            return this.props.data !== t3.data && this.editor.data.get() !== t3.data;
          }
          _getConfig() {
            const t3 = this.props.config || {};
            return this.props.data && t3.initialData && console.warn("Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified."), { ...t3, initialData: t3.initialData || this.props.data || "" };
          }
        }
        u.contextType = d, u.propTypes = { editor: r2().func.isRequired, data: r2().string, config: r2().object, disableWatchdog: r2().bool, watchdogConfig: r2().object, onChange: r2().func, onReady: r2().func, onFocus: r2().func, onBlur: r2().func, onError: r2().func, disabled: r2().bool, id: r2().any }, u._EditorWatchdog = s.EditorWatchdog;
        class l {
          constructor(t3) {
            this._contextWatchdog = t3, this._id = function() {
              const t4 = 4294967296 * Math.random() >>> 0, e3 = 4294967296 * Math.random() >>> 0, o3 = 4294967296 * Math.random() >>> 0, r3 = 4294967296 * Math.random() >>> 0;
              return "e" + i2[255 & t4] + i2[t4 >> 8 & 255] + i2[t4 >> 16 & 255] + i2[t4 >> 24 & 255] + i2[255 & e3] + i2[e3 >> 8 & 255] + i2[e3 >> 16 & 255] + i2[e3 >> 24 & 255] + i2[255 & o3] + i2[o3 >> 8 & 255] + i2[o3 >> 16 & 255] + i2[o3 >> 24 & 255] + i2[255 & r3] + i2[r3 >> 8 & 255] + i2[r3 >> 16 & 255] + i2[r3 >> 24 & 255];
            }();
          }
          setCreator(t3) {
            this._creator = t3;
          }
          create(t3, e3) {
            return this._contextWatchdog.add({ sourceElementOrData: t3, config: e3, creator: this._creator, id: this._id, type: "editor" });
          }
          on(t3, e3) {
            this._contextWatchdog.on("itemError", (t4, { itemId: o3, error: r3 }) => {
              o3 === this._id && e3(null, { error: r3, causesRestart: void 0 });
            });
          }
          destroy() {
            return "ready" === this._contextWatchdog.state ? this._contextWatchdog.remove(this._id) : Promise.resolve();
          }
          get editor() {
            return this._contextWatchdog.getItem(this._id);
          }
        }
        const p = "Lock from React integration (@ckeditor/ckeditor5-react)", g = ({ editor: o3 }) => {
          const r3 = (0, t2.useRef)(null);
          return (0, t2.useEffect)(() => {
            const t3 = r3.current;
            if (!o3 || !t3) return;
            const e3 = o3.ui.view.toolbar.element;
            return t3 && t3.appendChild(e3), () => {
              t3 && t3.removeChild(e3);
            };
          }, [o3 && o3.id]), e2().createElement("div", { ref: r3 });
        }, f = (o3) => {
          const r3 = (0, t2.useRef)(null), i3 = (0, t2.useRef)(null), n2 = (0, t2.useContext)(d), [a2, c2] = (0, t2.useState)(null), [h2, u2] = (0, t2.useState)(o3.data), [f2, y] = (0, t2.useState)(o3.rootsAttributes || {}), [m, b] = (0, t2.useState)([]), w = (0, t2.useRef)(true);
          (0, t2.useEffect)(() => ((async () => {
            await i3.current, false !== o3.isLayoutReady && await v();
          })(), () => {
            x().then(() => {
              i3.current = null;
            });
          }), [o3.isLayoutReady]), (0, t2.useEffect)(() => {
            a2 && (o3.disabled ? a2.enableReadOnlyMode(p) : a2.disableReadOnlyMode(p));
          }, [o3.disabled]), (0, t2.useEffect)(() => {
            if (a2 && !i3.current) {
              const t3 = a2.getFullData();
              u2({ ...t3 }), y({ ...a2.getRootsAttributes() }), b([...Object.keys(t3).map((t4) => C(a2, t4))]);
            }
          }, [a2 && a2.id]);
          const E = () => {
            const t3 = o3.config || {};
            return o3.data && t3.initialData && console.warn("Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified."), { ...t3, rootsAttributes: f2 };
          }, C = (t3, o4) => e2().createElement("div", { id: o4, key: o4, ref: (e3) => {
            if (e3) {
              const r4 = t3.ui.view.createEditable(o4, e3);
              t3.ui.addEditable(r4), t3.editing.view.forceRender();
            }
          } }), R = (t3, e3) => o3.editor.create(t3, e3).then((t4) => {
            o3.disabled && o3.disabled && t4.enableReadOnlyMode(p);
            const e4 = t4.model.document, r4 = t4.editing.view.document;
            return e4.on("change:data", (e5) => ((t5, e6) => {
              const r5 = t5.model.document;
              if (!o3.disableTwoWayDataBinding) {
                const e7 = {}, o4 = {};
                r5.differ.getChanges().forEach((o5) => {
                  let r6;
                  if (r6 = "insert" == o5.type || "remove" == o5.type ? o5.position.root : o5.range.root, !r6.isAttached()) return;
                  const { rootName: i4 } = r6;
                  e7[i4] = t5.getData({ rootName: i4 });
                }), r5.differ.getChangedRoots().forEach((r6) => {
                  if (r6.state) return void (void 0 !== e7[r6.name] && delete e7[r6.name]);
                  const i4 = r6.name;
                  o4[i4] = t5.getRootAttributes(i4);
                }), Object.keys(e7).length && u2((t6) => ({ ...t6, ...e7 })), Object.keys(o4).length && y((t6) => ({ ...t6, ...o4 }));
              }
              o3.onChange && o3.onChange(e6, t5);
            })(t4, e5)), t4.on("addRoot", (e5, r5) => ((t5, e6, r6) => {
              const i4 = r6.rootName, n3 = C(t5, i4);
              o3.disableTwoWayDataBinding || (u2((e7) => ({ ...e7, [i4]: t5.getData({ rootName: i4 }) })), y((e7) => ({ ...e7, [i4]: t5.getRootAttributes(i4) }))), b((t6) => [...t6, n3]);
            })(t4, 0, r5)), t4.on("detachRoot", (e5, r5) => ((t5, e6, r6) => {
              const i4 = r6.rootName;
              b((t6) => t6.filter((t7) => t7.props.id !== i4)), o3.disableTwoWayDataBinding || (u2((t6) => {
                const { [i4]: e7, ...o4 } = t6;
                return { ...o4 };
              }), y((t6) => {
                const { [i4]: e7, ...o4 } = t6;
                return { ...o4 };
              })), t5.detachEditable(r6);
            })(t4, 0, r5)), r4.on("focus", (e5) => {
              o3.onFocus && o3.onFocus(e5, t4);
            }), r4.on("blur", (e5) => {
              o3.onBlur && o3.onBlur(e5, t4);
            }), c2(t4), o3.onReady && o3.onReady(t4), t4;
          }), x = async () => {
            c2(null), u2({}), y({}), b([]), i3.current = new Promise((t3) => {
              setTimeout(async () => r3.current ? (await r3.current.destroy(), r3.current = null, t3()) : a2 ? (await a2.destroy(), t3()) : void t3());
            });
          }, v = async () => {
            if (o3.disableWatchdog) return void await R(o3.data, E());
            if (r3.current) return;
            n2 instanceof s.ContextWatchdog ? r3.current = new l(n2) : r3.current = new s.EditorWatchdog(o3.editor, o3.watchdogConfig);
            const t3 = r3.current;
            t3.setCreator((t4, e3) => R(t4, e3)), t3.on("error", (t4, { error: e3, causesRestart: r4 }) => {
              (o3.onError || console.error)(e3, { phase: "runtime", willEditorRestart: r4 });
            }), await t3.create(h2, E()).catch((t4) => {
              (o3.onError || console.error)(t4, { phase: "initialization", willEditorRestart: false });
            });
          };
          (0, t2.useEffect)(() => {
            if (a2 && w.current) {
              w.current = false;
              const t3 = Object.keys(h2), e3 = Object.keys(f2);
              if (!t3.every((t4) => e3.includes(t4))) throw new Error("`data` and `attributes` objects must have the same keys (roots).");
              const o4 = a2.getFullData(), r4 = a2.getRootsAttributes(), { addedKeys: i4, removedKeys: n3 } = W(o4, h2 || {}), s2 = t3.some((t4) => void 0 !== o4[t4] && JSON.stringify(o4[t4]) !== JSON.stringify(h2[t4])), d2 = e3.filter((t4) => JSON.stringify(r4[t4]) !== JSON.stringify(f2[t4]));
              a2.model.change((t4) => {
                _(i4), k(n3), s2 && O(), d2.length && D(t4, d2);
              });
            }
          }, [h2, f2]);
          const W = (t3, e3) => {
            const o4 = Object.keys(t3), r4 = Object.keys(e3);
            return { addedKeys: r4.filter((t4) => !o4.includes(t4)), removedKeys: o4.filter((t4) => !r4.includes(t4)) };
          }, _ = (t3) => {
            t3.forEach((t4) => {
              a2.addRoot(t4, { data: h2[t4] || "", attributes: (null == f2 ? void 0 : f2[t4]) || {}, isUndoable: true });
            });
          }, k = (t3) => {
            t3.forEach((t4) => {
              a2.detachRoot(t4, true);
            });
          }, O = () => {
            a2.data.set(h2, { suppressErrorInCollaboration: true });
          }, D = (t3, e3) => {
            e3.forEach((e4) => {
              Object.keys(f2[e4]).forEach((t4) => {
                a2.registerRootAttribute(t4);
              }), t3.clearAttributes(a2.model.document.getRoot(e4)), t3.setAttributes(f2[e4], a2.model.document.getRoot(e4));
            });
          }, j = (0, t2.useCallback)((t3) => {
            w.current = true, u2(t3);
          }, [u2]), S = (0, t2.useCallback)((t3) => {
            w.current = true, y(t3);
          }, [y]);
          return { editor: a2, editableElements: m, toolbarElement: e2().createElement(g, { editor: a2 }), data: h2, setData: j, attributes: f2, setAttributes: S };
        };
      })(), a;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

@ckeditor/ckeditor5-react/dist/index.js:
  (*!
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-react.js.map
