import {
  ContextWatchdog,
  EditorWatchdog,
  init_src
} from "./chunk-BVUMPJPL.js";
import {
  CKEditorError,
  Collection,
  Config,
  Conversion,
  DataController,
  EditingController,
  EmitterMixin,
  KeystrokeHandler,
  Locale,
  Model,
  ObservableMixin,
  StylesProcessor,
  crc32,
  env_default,
  global_default,
  insertToPriorityArray,
  logError,
  parseBase64EncodedObject,
  releaseDate,
  setDataInElement,
  toArray,
  uid
} from "./chunk-OOG4WH3K.js";
import {
  init_lodash,
  set_default
} from "./chunk-SWBFGANQ.js";
import {
  get_default
} from "./chunk-OX2NI5XB.js";
import "./chunk-SIFGPYD7.js";
import {
  isFunction_default
} from "./chunk-JABHAMWL.js";
import "./chunk-LK32TJAX.js";

// node_modules/@ckeditor/ckeditor5-core/src/plugin.js
var Plugin = class extends ObservableMixin() {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    super();
    this._disableStack = /* @__PURE__ */ new Set();
    this.editor = editor;
    this.set("isEnabled", true);
  }
  /**
   * Disables the plugin.
   *
   * Plugin may be disabled by multiple features or algorithms (at once). When disabling a plugin, unique id should be passed
   * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the plugin.
   * The plugin becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
   *
   * Disabling and enabling a plugin:
   *
   * ```ts
   * plugin.isEnabled; // -> true
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> false
   * plugin.clearForceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> true
   * ```
   *
   * Plugin disabled by multiple features:
   *
   * ```ts
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.forceDisabled( 'OtherFeature' );
   * plugin.clearForceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> false
   * plugin.clearForceDisabled( 'OtherFeature' );
   * plugin.isEnabled; // -> true
   * ```
   *
   * Multiple disabling with the same identifier is redundant:
   *
   * ```ts
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.forceDisabled( 'MyFeature' );
   * plugin.clearForceDisabled( 'MyFeature' );
   * plugin.isEnabled; // -> true
   * ```
   *
   * **Note:** some plugins or algorithms may have more complex logic when it comes to enabling or disabling certain plugins,
   * so the plugin might be still disabled after {@link #clearForceDisabled} was used.
   *
   * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the plugin.
   */
  forceDisabled(id) {
    this._disableStack.add(id);
    if (this._disableStack.size == 1) {
      this.on("set:isEnabled", forceDisable, { priority: "highest" });
      this.isEnabled = false;
    }
  }
  /**
   * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
   *
   * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
   */
  clearForceDisabled(id) {
    this._disableStack.delete(id);
    if (this._disableStack.size == 0) {
      this.off("set:isEnabled", forceDisable);
      this.isEnabled = true;
    }
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this.stopListening();
  }
  /**
   * @inheritDoc
   */
  static get isContextPlugin() {
    return false;
  }
  /**
   * @inheritDoc
   * @internal
   */
  static get isOfficialPlugin() {
    return false;
  }
  /**
   * @inheritDoc
   * @internal
   */
  static get isPremiumPlugin() {
    return false;
  }
};
function forceDisable(evt) {
  evt.return = false;
  evt.stop();
}

// node_modules/@ckeditor/ckeditor5-core/src/command.js
var Command = class extends ObservableMixin() {
  /**
   * Creates a new `Command` instance.
   *
   * @param editor The editor on which this command will be used.
   */
  constructor(editor) {
    super();
    this.editor = editor;
    this.set("value", void 0);
    this.set("isEnabled", false);
    this._affectsData = true;
    this._isEnabledBasedOnSelection = true;
    this._disableStack = /* @__PURE__ */ new Set();
    this.decorate("execute");
    this.listenTo(this.editor.model.document, "change", () => {
      this.refresh();
    });
    this.listenTo(editor, "change:isReadOnly", () => {
      this.refresh();
    });
    this.on("set:isEnabled", (evt) => {
      if (!this.affectsData) {
        return;
      }
      const selection = editor.model.document.selection;
      const selectionInGraveyard = selection.getFirstPosition().root.rootName == "$graveyard";
      const canEditAtSelection = !selectionInGraveyard && editor.model.canEditAt(selection);
      if (editor.isReadOnly || this._isEnabledBasedOnSelection && !canEditAtSelection) {
        evt.return = false;
        evt.stop();
      }
    }, { priority: "highest" });
    this.on("execute", (evt) => {
      if (!this.isEnabled) {
        evt.stop();
      }
    }, { priority: "high" });
  }
  /**
   * A flag indicating whether a command execution changes the editor data or not.
   *
   * Commands with `affectsData` set to `false` will not be automatically disabled in
   * the {@link module:core/editor/editor~Editor#isReadOnly read-only mode} and
   * {@glink features/read-only#related-features other editor modes} with restricted user write permissions.
   *
   * **Note:** You do not have to set it for your every command. It is `true` by default.
   *
   * @default true
   */
  get affectsData() {
    return this._affectsData;
  }
  set affectsData(affectsData) {
    this._affectsData = affectsData;
  }
  /**
   * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties
   * in this method.
   *
   * This method is automatically called when
   * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.
   */
  refresh() {
    this.isEnabled = true;
  }
  /**
   * Disables the command.
   *
   * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed
   * (e.g. the feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.
   * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
   *
   * Disabling and enabling a command:
   *
   * ```ts
   * command.isEnabled; // -> true
   * command.forceDisabled( 'MyFeature' );
   * command.isEnabled; // -> false
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * Command disabled by multiple features:
   *
   * ```ts
   * command.forceDisabled( 'MyFeature' );
   * command.forceDisabled( 'OtherFeature' );
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> false
   * command.clearForceDisabled( 'OtherFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * Multiple disabling with the same identifier is redundant:
   *
   * ```ts
   * command.forceDisabled( 'MyFeature' );
   * command.forceDisabled( 'MyFeature' );
   * command.clearForceDisabled( 'MyFeature' );
   * command.isEnabled; // -> true
   * ```
   *
   * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,
   * so the command might be still disabled after {@link #clearForceDisabled} was used.
   *
   * @param id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.
   */
  forceDisabled(id) {
    this._disableStack.add(id);
    if (this._disableStack.size == 1) {
      this.on("set:isEnabled", forceDisable2, { priority: "highest" });
      this.isEnabled = false;
    }
  }
  /**
   * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
   *
   * @param id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
   */
  clearForceDisabled(id) {
    this._disableStack.delete(id);
    if (this._disableStack.size == 0) {
      this.off("set:isEnabled", forceDisable2);
      this.refresh();
    }
  }
  /**
   * Executes the command.
   *
   * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}
   * to the command.
   *
   * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
   * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
   *
   * In order to see how to disable a command from "outside" see the {@link #isEnabled} documentation.
   *
   * This method may return a value, which would be forwarded all the way down to the
   * {@link module:core/editor/editor~Editor#execute `editor.execute()`}.
   *
   * @fires execute
   */
  execute(...args) {
    return void 0;
  }
  // eslint-disable-line @typescript-eslint/no-unused-vars
  /**
   * Destroys the command.
   */
  destroy() {
    this.stopListening();
  }
};
function forceDisable2(evt) {
  evt.return = false;
  evt.stop();
}

// node_modules/@ckeditor/ckeditor5-core/src/multicommand.js
var MultiCommand = class extends Command {
  constructor() {
    super(...arguments);
    this._childCommandsDefinitions = [];
  }
  /**
   * @inheritDoc
   */
  refresh() {
  }
  /**
   * Executes the first enabled command which has the highest priority of all registered child commands.
   *
   * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
   */
  execute(...args) {
    const command = this._getFirstEnabledCommand();
    return !!command && command.execute(args);
  }
  /**
   * Registers a child command.
   *
   * @param options An object with configuration options.
   * @param options.priority Priority of a command to register.
   */
  registerChildCommand(command, options = {}) {
    insertToPriorityArray(this._childCommandsDefinitions, { command, priority: options.priority || "normal" });
    command.on("change:isEnabled", () => this._checkEnabled());
    this._checkEnabled();
  }
  /**
   * Checks if any of child commands is enabled.
   */
  _checkEnabled() {
    this.isEnabled = !!this._getFirstEnabledCommand();
  }
  /**
   * Returns a first enabled command with the highest priority or `undefined` if none of them is enabled.
   */
  _getFirstEnabledCommand() {
    const commandDefinition = this._childCommandsDefinitions.find(({ command }) => command.isEnabled);
    return commandDefinition && commandDefinition.command;
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/plugincollection.js
var PluginCollection = class extends EmitterMixin() {
  /**
   * Creates an instance of the plugin collection class.
   * Allows loading and initializing plugins and their dependencies.
   * Allows providing a list of already loaded plugins. These plugins will not be destroyed along with this collection.
   *
   * @param availablePlugins Plugins (constructors) which the collection will be able to use
   * when {@link module:core/plugincollection~PluginCollection#init} is used with the plugin names (strings, instead of constructors).
   * Usually, the editor will pass its built-in plugins to the collection so they can later be
   * used in `config.plugins` or `config.removePlugins` by names.
   * @param contextPlugins A list of already initialized plugins represented by a `[ PluginConstructor, pluginInstance ]` pair.
   */
  constructor(context, availablePlugins = [], contextPlugins = []) {
    super();
    this._plugins = /* @__PURE__ */ new Map();
    this._context = context;
    this._availablePlugins = /* @__PURE__ */ new Map();
    for (const PluginConstructor of availablePlugins) {
      if (PluginConstructor.pluginName) {
        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
      }
    }
    this._contextPlugins = /* @__PURE__ */ new Map();
    for (const [PluginConstructor, pluginInstance] of contextPlugins) {
      this._contextPlugins.set(PluginConstructor, pluginInstance);
      this._contextPlugins.set(pluginInstance, PluginConstructor);
      if (PluginConstructor.pluginName) {
        this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
      }
    }
  }
  /**
   * Iterable interface.
   *
   * Returns `[ PluginConstructor, pluginInstance ]` pairs.
   */
  *[Symbol.iterator]() {
    for (const entry of this._plugins) {
      if (typeof entry[0] == "function") {
        yield entry;
      }
    }
  }
  /**
   * Gets the plugin instance by its constructor or name.
   *
   * ```ts
   * // Check if 'Clipboard' plugin was loaded.
   * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
   * 	// Get clipboard plugin instance
   * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
   *
   * 	this.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {
   * 		// Do something on clipboard input.
   * 	} );
   * }
   * ```
   *
   * **Note**: This method will throw an error if a plugin is not loaded. Use `{@link #has editor.plugins.has()}`
   * to check if a plugin is available.
   *
   * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
   */
  get(key) {
    const plugin = this._plugins.get(key);
    if (!plugin) {
      let pluginName = key;
      if (typeof key == "function") {
        pluginName = key.pluginName || key.name;
      }
      throw new CKEditorError("plugincollection-plugin-not-loaded", this._context, { plugin: pluginName });
    }
    return plugin;
  }
  /**
   * Checks if a plugin is loaded.
   *
   * ```ts
   * // Check if the 'Clipboard' plugin was loaded.
   * if ( editor.plugins.has( 'ClipboardPipeline' ) ) {
   * 	// Now use the clipboard plugin instance:
   * 	const clipboard = editor.plugins.get( 'ClipboardPipeline' );
   *
   * 	// ...
   * }
   * ```
   *
   * @param key The plugin constructor or {@link module:core/plugin~PluginStaticMembers#pluginName name}.
   */
  has(key) {
    return this._plugins.has(key);
  }
  /**
   * Initializes a set of plugins and adds them to the collection.
   *
   * @param plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
   * or {@link module:core/plugin~PluginStaticMembers#pluginName plugin names}.
   * @param pluginsToRemove Names of the plugins or plugin constructors
   * that should not be loaded (despite being specified in the `plugins` array).
   * @param pluginsSubstitutions An array of {@link module:core/plugin~PluginInterface plugin constructors}
   * that will be used to replace plugins of the same names that were passed in `plugins` or that are in their dependency tree.
   * A useful option for replacing built-in plugins while creating tests (for mocking their APIs). Plugins that will be replaced
   * must follow these rules:
   *   * The new plugin must be a class.
   *   * The new plugin must be named.
   *   * Both plugins must not depend on other plugins.
   * @returns A promise which gets resolved once all plugins are loaded and available in the collection.
   */
  init(plugins, pluginsToRemove = [], pluginsSubstitutions = []) {
    const that = this;
    const context = this._context;
    findAvailablePluginConstructors(plugins);
    validatePlugins(plugins);
    const pluginsToLoad = plugins.filter((plugin) => !isPluginRemoved(plugin, pluginsToRemove));
    const pluginConstructors = [...getPluginConstructors(pluginsToLoad)];
    substitutePlugins(pluginConstructors, pluginsSubstitutions);
    const pluginInstances = loadPlugins(pluginConstructors);
    return initPlugins(pluginInstances, "init").then(() => initPlugins(pluginInstances, "afterInit")).then(() => pluginInstances);
    function isPluginConstructor(plugin) {
      return typeof plugin === "function";
    }
    function isContextPlugin(plugin) {
      return isPluginConstructor(plugin) && !!plugin.isContextPlugin;
    }
    function isPluginRemoved(plugin, pluginsToRemove2) {
      return pluginsToRemove2.some((removedPlugin) => {
        if (removedPlugin === plugin) {
          return true;
        }
        if (getPluginName(plugin) === removedPlugin) {
          return true;
        }
        if (getPluginName(removedPlugin) === plugin) {
          return true;
        }
        return false;
      });
    }
    function getPluginName(plugin) {
      return isPluginConstructor(plugin) ? plugin.pluginName || plugin.name : plugin;
    }
    function findAvailablePluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
      plugins2.forEach((plugin) => {
        if (!isPluginConstructor(plugin)) {
          return;
        }
        if (processed.has(plugin)) {
          return;
        }
        processed.add(plugin);
        if (plugin.pluginName && !that._availablePlugins.has(plugin.pluginName)) {
          that._availablePlugins.set(plugin.pluginName, plugin);
        }
        if (plugin.requires) {
          findAvailablePluginConstructors(plugin.requires, processed);
        }
      });
    }
    function getPluginConstructors(plugins2, processed = /* @__PURE__ */ new Set()) {
      return plugins2.map((plugin) => {
        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin);
      }).reduce((result, plugin) => {
        if (processed.has(plugin)) {
          return result;
        }
        processed.add(plugin);
        if (plugin.requires) {
          validatePlugins(plugin.requires, plugin);
          getPluginConstructors(plugin.requires, processed).forEach((plugin2) => result.add(plugin2));
        }
        return result.add(plugin);
      }, /* @__PURE__ */ new Set());
    }
    function validatePlugins(plugins2, parentPluginConstructor = null) {
      plugins2.map((plugin) => {
        return isPluginConstructor(plugin) ? plugin : that._availablePlugins.get(plugin) || plugin;
      }).forEach((plugin) => {
        checkMissingPlugin(plugin, parentPluginConstructor);
        checkContextPlugin(plugin, parentPluginConstructor);
        checkRemovedPlugin(plugin, parentPluginConstructor);
      });
    }
    function checkMissingPlugin(plugin, parentPluginConstructor) {
      if (isPluginConstructor(plugin)) {
        return;
      }
      if (parentPluginConstructor) {
        throw new CKEditorError("plugincollection-soft-required", context, { missingPlugin: plugin, requiredBy: getPluginName(parentPluginConstructor) });
      }
      throw new CKEditorError("plugincollection-plugin-not-found", context, { plugin });
    }
    function checkContextPlugin(plugin, parentPluginConstructor) {
      if (!isContextPlugin(parentPluginConstructor)) {
        return;
      }
      if (isContextPlugin(plugin)) {
        return;
      }
      throw new CKEditorError("plugincollection-context-required", context, { plugin: getPluginName(plugin), requiredBy: getPluginName(parentPluginConstructor) });
    }
    function checkRemovedPlugin(plugin, parentPluginConstructor) {
      if (!parentPluginConstructor) {
        return;
      }
      if (!isPluginRemoved(plugin, pluginsToRemove)) {
        return;
      }
      throw new CKEditorError("plugincollection-required", context, { plugin: getPluginName(plugin), requiredBy: getPluginName(parentPluginConstructor) });
    }
    function loadPlugins(pluginConstructors2) {
      return pluginConstructors2.map((PluginConstructor) => {
        let pluginInstance = that._contextPlugins.get(PluginConstructor);
        pluginInstance = pluginInstance || new PluginConstructor(context);
        that._add(PluginConstructor, pluginInstance);
        return pluginInstance;
      });
    }
    function initPlugins(pluginInstances2, method) {
      return pluginInstances2.reduce((promise, plugin) => {
        if (!plugin[method]) {
          return promise;
        }
        if (that._contextPlugins.has(plugin)) {
          return promise;
        }
        return promise.then(plugin[method].bind(plugin));
      }, Promise.resolve());
    }
    function substitutePlugins(pluginConstructors2, pluginsSubstitutions2) {
      for (const pluginItem of pluginsSubstitutions2) {
        if (typeof pluginItem != "function") {
          throw new CKEditorError("plugincollection-replace-plugin-invalid-type", null, { pluginItem });
        }
        const pluginName = pluginItem.pluginName;
        if (!pluginName) {
          throw new CKEditorError("plugincollection-replace-plugin-missing-name", null, { pluginItem });
        }
        if (pluginItem.requires && pluginItem.requires.length) {
          throw new CKEditorError("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName });
        }
        const pluginToReplace = that._availablePlugins.get(pluginName);
        if (!pluginToReplace) {
          throw new CKEditorError("plugincollection-plugin-for-replacing-not-exist", null, { pluginName });
        }
        const indexInPluginConstructors = pluginConstructors2.indexOf(pluginToReplace);
        if (indexInPluginConstructors === -1) {
          if (that._contextPlugins.has(pluginToReplace)) {
            return;
          }
          throw new CKEditorError("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName });
        }
        if (pluginToReplace.requires && pluginToReplace.requires.length) {
          throw new CKEditorError("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName });
        }
        pluginConstructors2.splice(indexInPluginConstructors, 1, pluginItem);
        that._availablePlugins.set(pluginName, pluginItem);
      }
    }
  }
  /**
   * Destroys all loaded plugins.
   */
  destroy() {
    const promises = [];
    for (const [, pluginInstance] of this) {
      if (typeof pluginInstance.destroy == "function" && !this._contextPlugins.has(pluginInstance)) {
        promises.push(pluginInstance.destroy());
      }
    }
    return Promise.all(promises);
  }
  /**
   * Adds the plugin to the collection. Exposed mainly for testing purposes.
   *
   * @param PluginConstructor The plugin constructor.
   * @param plugin The instance of the plugin.
   */
  _add(PluginConstructor, plugin) {
    this._plugins.set(PluginConstructor, plugin);
    const pluginName = PluginConstructor.pluginName;
    if (!pluginName) {
      return;
    }
    if (this._plugins.has(pluginName)) {
      throw new CKEditorError("plugincollection-plugin-name-conflict", null, { pluginName, plugin1: this._plugins.get(pluginName).constructor, plugin2: PluginConstructor });
    }
    this._plugins.set(pluginName, plugin);
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/context.js
var Context = class {
  /**
   * Creates a context instance with a given configuration.
   *
   * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.
   *
   * @param config The context configuration.
   */
  constructor(config) {
    this._contextOwner = null;
    const { translations, ...rest } = config || {};
    this.config = new Config(rest, this.constructor.defaultConfig);
    const availablePlugins = this.constructor.builtinPlugins;
    this.config.define("plugins", availablePlugins);
    this.plugins = new PluginCollection(this, availablePlugins);
    const languageConfig = this.config.get("language") || {};
    this.locale = new Locale({
      uiLanguage: typeof languageConfig === "string" ? languageConfig : languageConfig.ui,
      contentLanguage: this.config.get("language.content"),
      translations
    });
    this.t = this.locale.t;
    this.editors = new Collection();
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
   */
  initPlugins() {
    const plugins = this.config.get("plugins") || [];
    const substitutePlugins = this.config.get("substitutePlugins") || [];
    for (const Plugin2 of plugins.concat(substitutePlugins)) {
      if (typeof Plugin2 != "function") {
        throw new CKEditorError("context-initplugins-constructor-only", null, { Plugin: Plugin2 });
      }
      if (Plugin2.isContextPlugin !== true) {
        throw new CKEditorError("context-initplugins-invalid-plugin", null, { Plugin: Plugin2 });
      }
    }
    return this.plugins.init(plugins, [], substitutePlugins);
  }
  /**
   * Destroys the context instance and all editors used with the context,
   * releasing all resources used by the context.
   *
   * @returns A promise that resolves once the context instance is fully destroyed.
   */
  destroy() {
    return Promise.all(Array.from(this.editors, (editor) => editor.destroy())).then(() => this.plugins.destroy());
  }
  /**
   * Adds a reference to the editor which is used with this context.
   *
   * When the given editor has created the context, the reference to this editor will be stored
   * as a {@link ~Context#_contextOwner}.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @param isContextOwner Stores the given editor as a context owner.
   */
  _addEditor(editor, isContextOwner) {
    if (this._contextOwner) {
      throw new CKEditorError("context-addeditor-private-context");
    }
    this.editors.add(editor);
    if (isContextOwner) {
      this._contextOwner = editor;
    }
  }
  /**
   * Removes a reference to the editor which was used with this context.
   * When the context was created by the given editor, the context will be destroyed.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @return A promise that resolves once the editor is removed from the context or when the context was destroyed.
   */
  _removeEditor(editor) {
    if (this.editors.has(editor)) {
      this.editors.remove(editor);
    }
    if (this._contextOwner === editor) {
      return this.destroy();
    }
    return Promise.resolve();
  }
  /**
   * Returns the context configuration which will be copied to the editors created using this context.
   *
   * The configuration returned by this method has the plugins configuration removed &ndash; plugins are shared with all editors
   * through another mechanism.
   *
   * This method should only be used by the editor.
   *
   * @internal
   * @returns Configuration as a plain object.
   */
  _getEditorConfig() {
    const result = {};
    for (const name of this.config.names()) {
      if (!["plugins", "removePlugins", "extraPlugins"].includes(name)) {
        result[name] = this.config.get(name);
      }
    }
    return result;
  }
  /**
   * Creates and initializes a new context instance.
   *
   * ```ts
   * const commonConfig = { ... }; // Configuration for all the plugins and editors.
   * const editorPlugins = [ ... ]; // Regular plugins here.
   *
   * Context
   * 	.create( {
   * 		// Only context plugins here.
   * 		plugins: [ ... ],
   *
   * 		// Configure the language for all the editors (it cannot be overwritten).
   * 		language: { ... },
   *
   * 		// Configuration for context plugins.
   * 		comments: { ... },
   * 		...
   *
   * 		// Default configuration for editor plugins.
   * 		toolbar: { ... },
   * 		image: { ... },
   * 		...
   * 	} )
   * 	.then( context => {
   * 		const promises = [];
   *
   * 		promises.push( ClassicEditor.create(
   * 			document.getElementById( 'editor1' ),
   * 			{
   * 				editorPlugins,
   * 				context
   * 			}
   * 		) );
   *
   * 		promises.push( ClassicEditor.create(
   * 			document.getElementById( 'editor2' ),
   * 			{
   * 				editorPlugins,
   * 				context,
   * 				toolbar: { ... } // You can overwrite the configuration of the context.
   * 			}
   * 		) );
   *
   * 		return Promise.all( promises );
   * 	} );
   * ```
   *
   * @param config The context configuration.
   * @returns A promise resolved once the context is ready. The promise resolves with the created context instance.
   */
  static create(config) {
    return new Promise((resolve) => {
      const context = new this(config);
      resolve(context.initPlugins().then(() => context));
    });
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/contextplugin.js
var ContextPlugin = class extends ObservableMixin() {
  /**
   * Creates a new plugin instance.
   */
  constructor(context) {
    super();
    this.context = context;
  }
  /**
   * @inheritDoc
   */
  destroy() {
    this.stopListening();
  }
  /**
   * @inheritDoc
   */
  static get isContextPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return false;
  }
  /**
   * @inheritDoc
   */
  static get isPremiumPlugin() {
    return false;
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/editor/editor.js
init_lodash();
init_src();

// node_modules/@ckeditor/ckeditor5-core/src/commandcollection.js
var CommandCollection = class {
  /**
   * Creates collection instance.
   */
  constructor() {
    this._commands = /* @__PURE__ */ new Map();
  }
  /**
   * Registers a new command.
   *
   * @param commandName The name of the command.
   */
  add(commandName, command) {
    this._commands.set(commandName, command);
  }
  /**
   * Retrieves a command from the collection.
   *
   * @param commandName The name of the command.
   */
  get(commandName) {
    return this._commands.get(commandName);
  }
  /**
   * Executes a command.
   *
   * @param commandName The name of the command.
   * @param commandParams Command parameters.
   * @returns The value returned by the {@link module:core/command~Command#execute `command.execute()`}.
   */
  execute(commandName, ...commandParams) {
    const command = this.get(commandName);
    if (!command) {
      throw new CKEditorError("commandcollection-command-not-found", this, { commandName });
    }
    return command.execute(...commandParams);
  }
  /**
   * Returns iterator of command names.
   */
  *names() {
    yield* this._commands.keys();
  }
  /**
   * Returns iterator of command instances.
   */
  *commands() {
    yield* this._commands.values();
  }
  /**
   * Iterable interface.
   *
   * Returns `[ commandName, commandInstance ]` pairs.
   */
  [Symbol.iterator]() {
    return this._commands[Symbol.iterator]();
  }
  /**
   * Destroys all collection commands.
   */
  destroy() {
    for (const command of this.commands()) {
      command.destroy();
    }
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/editingkeystrokehandler.js
var EditingKeystrokeHandler = class extends KeystrokeHandler {
  /**
   * Creates an instance of the keystroke handler.
   */
  constructor(editor) {
    super();
    this.editor = editor;
  }
  /**
   * Registers a handler for the specified keystroke.
   *
   * The handler can be specified as a command name or a callback.
   *
   * @param keystroke Keystroke defined in a format accepted by
   * the {@link module:utils/keyboard~parseKeystroke} function.
   * @param callback If a string is passed, then the keystroke will
   * {@link module:core/editor/editor~Editor#execute execute a command}.
   * If a function, then it will be called with the
   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
   * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
   * @param options Additional options.
   * @param options.priority The priority of the keystroke callback. The higher the priority value
   * the sooner the callback will be executed. Keystrokes having the same priority
   * are called in the order they were added.
   */
  set(keystroke, callback, options = {}) {
    if (typeof callback == "string") {
      const commandName = callback;
      callback = (evtData, cancel2) => {
        this.editor.execute(commandName);
        cancel2();
      };
    }
    super.set(keystroke, callback, options);
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/accessibility.js
var DEFAULT_CATEGORY_ID = "contentEditing";
var DEFAULT_GROUP_ID = "common";
var Accessibility = class {
  /**
   * @inheritDoc
   */
  constructor(editor) {
    this.keystrokeInfos = /* @__PURE__ */ new Map();
    this._editor = editor;
    const isMenuBarVisible = editor.config.get("menuBar.isVisible");
    const t = editor.locale.t;
    this.addKeystrokeInfoCategory({
      id: DEFAULT_CATEGORY_ID,
      label: t("Content editing keystrokes"),
      description: t("These keyboard shortcuts allow for quick access to content editing features.")
    });
    const navigationKeystrokes = [
      {
        label: t("Close contextual balloons, dropdowns, and dialogs"),
        keystroke: "Esc"
      },
      {
        label: t("Open the accessibility help dialog"),
        keystroke: "Alt+0"
      },
      {
        label: t("Move focus between form fields (inputs, buttons, etc.)"),
        keystroke: [["Tab"], ["Shift+Tab"]]
      },
      {
        label: t("Move focus to the toolbar, navigate between toolbars"),
        keystroke: "Alt+F10",
        mayRequireFn: true
      },
      {
        label: t("Navigate through the toolbar or menu bar"),
        keystroke: [["arrowup"], ["arrowright"], ["arrowdown"], ["arrowleft"]]
      },
      {
        // eslint-disable-next-line max-len
        label: t("Execute the currently focused button. Executing buttons that interact with the editor content moves the focus back to the content."),
        keystroke: [["Enter"], ["Space"]]
      }
    ];
    if (isMenuBarVisible) {
      navigationKeystrokes.push({
        label: t("Move focus to the menu bar, navigate between menu bars"),
        keystroke: "Alt+F9",
        mayRequireFn: true
      });
    }
    this.addKeystrokeInfoCategory({
      id: "navigation",
      label: t("User interface and content navigation keystrokes"),
      description: t("Use the following keystrokes for more efficient navigation in the CKEditor 5 user interface."),
      groups: [
        {
          id: "common",
          keystrokes: navigationKeystrokes
        }
      ]
    });
  }
  /**
   * Adds a top-level category in the {@link #keystrokeInfos keystroke information database} with a label and optional description.
   *
   * Categories organize keystrokes and help users to find the right keystroke. Each category can have multiple groups
   * of keystrokes that narrow down the context in which the keystrokes are available. Every keystroke category comes
   * with a `'common'` group by default.
   *
   * By default, two categories are available:
   * * `'contentEditing'` for keystrokes related to content creation,
   * * `'navigation'` for keystrokes related to navigation in the UI and the content.
   *
   * To create a new keystroke category with new groups, use the following code:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfoCategory( {
   * 			id: 'myCategory',
   * 			label: t( 'My category' ),
   * 			description: t( 'My category description.' ),
   * 			groups: [
   * 				{
   * 					id: 'myGroup',
   * 					label: t( 'My keystroke group' ),
   * 					keystrokes: [
   * 						{
   * 							label: t( 'Keystroke label 1' ),
   * 							keystroke: 'Ctrl+Shift+N'
   * 						},
   * 						{
   * 							label: t( 'Keystroke label 2' ),
   * 							keystroke: 'Ctrl+Shift+M'
   * 						}
   * 					]
   * 				}
   * 			]
   * 		};
   * 	}
   * }
   * ```
   *
   * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfos}.
   */
  addKeystrokeInfoCategory({ id, label, description, groups }) {
    this.keystrokeInfos.set(id, {
      id,
      label,
      description,
      groups: /* @__PURE__ */ new Map()
    });
    this.addKeystrokeInfoGroup({
      categoryId: id,
      id: DEFAULT_GROUP_ID
    });
    if (groups) {
      groups.forEach((group) => {
        this.addKeystrokeInfoGroup({
          categoryId: id,
          ...group
        });
      });
    }
  }
  /**
   * Adds a group of keystrokes in a specific category to the {@link #keystrokeInfos keystroke information database}.
   *
   * Groups narrow down the context in which the keystrokes are available. When `categoryId` is not specified,
   * the group goes to the `'contentEditing'` category (default).
   *
   * To create a new group within an existing category, use the following code:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfoGroup( {
   * 			id: 'myGroup',
   * 			categoryId: 'navigation',
   * 			label: t( 'My keystroke group' ),
   * 			keystrokes: [
   * 				{
   * 					label: t( 'Keystroke label 1' ),
   * 					keystroke: 'Ctrl+Shift+N'
   * 				},
   * 				{
   * 					label: t( 'Keystroke label 2' ),
   * 					keystroke: 'Ctrl+Shift+M'
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   *
   * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoCategory}, and {@link #addKeystrokeInfos}.
   */
  addKeystrokeInfoGroup({ categoryId = DEFAULT_CATEGORY_ID, id, label, keystrokes }) {
    const category = this.keystrokeInfos.get(categoryId);
    if (!category) {
      throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, { groupId: id, categoryId });
    }
    category.groups.set(id, {
      id,
      label,
      keystrokes: keystrokes || []
    });
  }
  /**
   * Adds information about keystrokes to the {@link #keystrokeInfos keystroke information database}.
   *
   * Keystrokes without specified `groupId` or `categoryId` go to the `'common'` group in the `'contentEditing'` category (default).
   *
   * To add a keystroke brought by your plugin (using default group and category), use the following code:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfos( {
   * 			keystrokes: [
   * 				{
   * 					label: t( 'Keystroke label' ),
   * 					keystroke: 'CTRL+B'
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   * To add a keystroke in a specific existing `'widget'` group in the default `'contentEditing'` category:
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfos( {
   * 			// Add a keystroke to the existing "widget" group.
   * 			groupId: 'widget',
   * 			keystrokes: [
   * 				{
   * 					label: t( 'A an action on a selected widget' ),
   * 					keystroke: 'Ctrl+D',
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   *
   * To add a keystroke to another existing category (using default group):
   *
   * ```js
   * class MyPlugin extends Plugin {
   * 	// ...
   * 	init() {
   * 		const editor = this.editor;
   * 		const t = editor.t;
   *
   * 		// ...
   *
   * 		editor.accessibility.addKeystrokeInfos( {
   * 			// Add keystrokes to the "navigation" category (one of defaults).
   * 			categoryId: 'navigation',
   * 			keystrokes: [
   * 				{
   * 					label: t( 'Keystroke label' ),
   * 					keystroke: 'CTRL+B'
   * 				}
   * 			]
   * 		} );
   * 	}
   * }
   * ```
   *
   * See {@link #keystrokeInfos}, {@link #addKeystrokeInfoGroup}, and {@link #addKeystrokeInfoCategory}.
   */
  addKeystrokeInfos({ categoryId = DEFAULT_CATEGORY_ID, groupId = DEFAULT_GROUP_ID, keystrokes }) {
    if (!this.keystrokeInfos.has(categoryId)) {
      throw new CKEditorError("accessibility-unknown-keystroke-info-category", this._editor, { categoryId, keystrokes });
    }
    const category = this.keystrokeInfos.get(categoryId);
    if (!category.groups.has(groupId)) {
      throw new CKEditorError("accessibility-unknown-keystroke-info-group", this._editor, { groupId, categoryId, keystrokes });
    }
    category.groups.get(groupId).keystrokes.push(...keystrokes);
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/editorusagedata.js
function getEditorUsageData(editor) {
  return {
    sessionId: getSessionId(),
    pageSessionId: getPageSessionID(),
    hostname: window.location.hostname,
    version: globalThis.CKEDITOR_VERSION,
    type: getEditorType(editor),
    plugins: getPluginsUsageData(editor.plugins),
    distribution: getDistributionUsageData(),
    env: getEnvUsageData(),
    integration: /* @__PURE__ */ Object.create(null),
    menuBar: {
      isVisible: !!editor.config.get("menuBar.isVisible")
    },
    language: {
      ui: editor.locale.uiLanguage,
      content: editor.locale.contentLanguage
    },
    toolbar: {
      main: getToolbarUsageData(editor.config.get("toolbar")),
      block: getToolbarUsageData(editor.config.get("blockToolbar")),
      balloon: getToolbarUsageData(editor.config.get("balloonToolbar"))
    }
  };
}
function getEditorType(editor) {
  return Object.getPrototypeOf(editor).constructor.editorName;
}
function getPluginsUsageData(collection) {
  return Array.from(collection).filter(([PluginConstructor]) => !!PluginConstructor.pluginName).map(([PluginConstructor]) => {
    const { pluginName, isContextPlugin, isOfficialPlugin, isPremiumPlugin } = PluginConstructor;
    return {
      isContext: !!isContextPlugin,
      isOfficial: !!isOfficialPlugin,
      isPremium: !!isPremiumPlugin,
      name: pluginName
    };
  });
}
function getToolbarUsageData(toolbarConfig) {
  if (!toolbarConfig) {
    return void 0;
  }
  const normalizedToolbar = Array.isArray(toolbarConfig) ? { items: toolbarConfig } : toolbarConfig;
  const flattenToolbarConfigNames = extractToolbarConfigItemsNames(normalizedToolbar.items || []);
  const isMultiline = flattenToolbarConfigNames.includes("-");
  return {
    isMultiline,
    shouldNotGroupWhenFull: !!normalizedToolbar.shouldNotGroupWhenFull,
    items: stripToolbarSeparatorItems(flattenToolbarConfigNames)
  };
  function stripToolbarSeparatorItems(items) {
    return items.filter((item) => item !== "|" && item !== "-");
  }
  function extractToolbarConfigItemsNames(items) {
    return items.flatMap((item) => {
      if (typeof item === "string") {
        return [item];
      }
      return extractToolbarConfigItemsNames(item.items);
    });
  }
}
function getDistributionUsageData() {
  return {
    channel: window[Symbol.for("cke distribution")] || "sh"
  };
}
function getEnvUsageData() {
  let os = "unknown";
  let browser = "unknown";
  if (env_default.isMac) {
    os = "mac";
  } else if (env_default.isWindows) {
    os = "windows";
  } else if (env_default.isiOS) {
    os = "ios";
  } else if (env_default.isAndroid) {
    os = "android";
  }
  if (env_default.isGecko) {
    browser = "gecko";
  } else if (env_default.isBlink) {
    browser = "blink";
  } else if (env_default.isSafari) {
    browser = "safari";
  }
  return {
    os,
    browser
  };
}
function getSessionId() {
  if (!localStorage.getItem("__ckeditor-session-id")) {
    localStorage.setItem("__ckeditor-session-id", uid());
  }
  return localStorage.getItem("__ckeditor-session-id");
}
function getPageSessionID() {
  global_default.window.CKEDITOR_PAGE_SESSION_ID = global_default.window.CKEDITOR_PAGE_SESSION_ID || uid();
  return global_default.window.CKEDITOR_PAGE_SESSION_ID;
}

// node_modules/@ckeditor/ckeditor5-core/src/editor/editor.js
var Editor = class extends ObservableMixin() {
  /**
   * A required name of the editor class. The name should reflect the constructor name.
   */
  static get editorName() {
    return "Editor";
  }
  /**
   * Creates a new instance of the editor class.
   *
   * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.
   *
   * @param config The editor configuration.
   */
  constructor(config = {}) {
    super();
    if ("sanitizeHtml" in config) {
      throw new CKEditorError("editor-config-sanitizehtml-not-supported");
    }
    const constructor = this.constructor;
    const { translations: defaultTranslations, ...defaultConfig } = constructor.defaultConfig || {};
    const { translations = defaultTranslations, ...rest } = config;
    const language = config.language || defaultConfig.language;
    this._context = config.context || new Context({ language, translations });
    this._context._addEditor(this, !config.context);
    const availablePlugins = Array.from(constructor.builtinPlugins || []);
    this.config = new Config(rest, defaultConfig);
    this.config.define("plugins", availablePlugins);
    this.config.define(this._context._getEditorConfig());
    checkLicenseKeyIsDefined(this.config);
    this.plugins = new PluginCollection(this, availablePlugins, this._context.plugins);
    this.locale = this._context.locale;
    this.t = this.locale.t;
    this._readOnlyLocks = /* @__PURE__ */ new Set();
    this.commands = new CommandCollection();
    this.set("state", "initializing");
    this.once("ready", () => this.state = "ready", { priority: "high" });
    this.once("destroy", () => this.state = "destroyed", { priority: "high" });
    this.model = new Model();
    this.on("change:isReadOnly", () => {
      this.model.document.isReadOnly = this.isReadOnly;
    });
    const stylesProcessor = new StylesProcessor();
    this.data = new DataController(this.model, stylesProcessor);
    this.editing = new EditingController(this.model, stylesProcessor);
    this.editing.view.document.bind("isReadOnly").to(this);
    this.conversion = new Conversion([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);
    this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher);
    this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher);
    this.keystrokes = new EditingKeystrokeHandler(this);
    this.keystrokes.listenTo(this.editing.view.document);
    this.accessibility = new Accessibility(this);
    verifyLicenseKey(this);
    function checkLicenseKeyIsDefined(config2) {
      let licenseKey = config2.get("licenseKey");
      if (!licenseKey && window.CKEDITOR_GLOBAL_LICENSE_KEY) {
        licenseKey = window.CKEDITOR_GLOBAL_LICENSE_KEY;
        config2.set("licenseKey", licenseKey);
      }
      if (!licenseKey) {
        throw new CKEditorError("license-key-missing");
      }
    }
    function verifyLicenseKey(editor) {
      const licenseKey = editor.config.get("licenseKey");
      const distributionChannel = window[Symbol.for("cke distribution")] || "sh";
      function blockEditor(reason) {
        editor.enableReadOnlyMode(Symbol("invalidLicense"));
        editor._showLicenseError(reason);
      }
      function getPayload(licenseKey2) {
        const parts = licenseKey2.split(".");
        if (parts.length != 3) {
          return null;
        }
        return parts[1];
      }
      function hasAllRequiredFields(licensePayload2) {
        const requiredFields = ["exp", "jti", "vc"];
        return requiredFields.every((field) => field in licensePayload2);
      }
      function getCrcInputData(licensePayload2) {
        const keysToCheck = Object.getOwnPropertyNames(licensePayload2).sort();
        const filteredValues = keysToCheck.filter((key) => key != "vc" && licensePayload2[key] != null).map((key) => licensePayload2[key]);
        return filteredValues;
      }
      function checkLicensedHosts(licensedHosts2) {
        const { hostname } = new URL(window.location.href);
        if (licensedHosts2.includes(hostname)) {
          return true;
        }
        const segments = hostname.split(".");
        return licensedHosts2.filter((host) => host.includes("*")).map((host) => host.split(".")).filter((host) => host.length <= segments.length).map((host) => Array(segments.length - host.length).fill(host[0] === "*" ? "*" : "").concat(host)).some((octets) => segments.every((segment, index) => octets[index] === segment || octets[index] === "*"));
      }
      if (licenseKey == "GPL") {
        if (distributionChannel == "cloud") {
          blockEditor("distributionChannel");
        }
        return;
      }
      const encodedPayload = getPayload(licenseKey);
      if (!encodedPayload) {
        blockEditor("invalid");
        return;
      }
      const licensePayload = parseBase64EncodedObject(encodedPayload);
      if (!licensePayload) {
        blockEditor("invalid");
        return;
      }
      if (!hasAllRequiredFields(licensePayload)) {
        blockEditor("invalid");
        return;
      }
      if (licensePayload.distributionChannel && !toArray(licensePayload.distributionChannel).includes(distributionChannel)) {
        blockEditor("distributionChannel");
        return;
      }
      if (crc32(getCrcInputData(licensePayload)) != licensePayload.vc.toLowerCase()) {
        blockEditor("invalid");
        return;
      }
      const expirationDate = new Date(licensePayload.exp * 1e3);
      if (expirationDate < releaseDate) {
        blockEditor("expired");
        return;
      }
      const licensedHosts = licensePayload.licensedHosts;
      if (licensedHosts && licensedHosts.length > 0 && !checkLicensedHosts(licensedHosts)) {
        blockEditor("domainLimit");
        return;
      }
      if (["evaluation", "trial"].includes(licensePayload.licenseType) && licensePayload.exp * 1e3 < Date.now()) {
        blockEditor("expired");
        return;
      }
      if (["development", "evaluation", "trial"].includes(licensePayload.licenseType)) {
        const { licenseType } = licensePayload;
        const capitalizedLicenseType = licenseType[0].toUpperCase() + licenseType.slice(1);
        console.info(`%cCKEditor 5 ${capitalizedLicenseType} License`, "color: #ffffff; background: #743CCD; font-size: 14px; padding: 4px 8px; border-radius: 4px;");
        console.warn(`⚠️ You are using a ${licenseType} license of CKEditor 5${licenseType === "trial" ? " which is for evaluation purposes only" : ""}. For production usage, please obtain a production license at https://portal.ckeditor.com/`);
      }
      if (["evaluation", "trial"].includes(licensePayload.licenseType)) {
        const licenseType = licensePayload.licenseType;
        const timerId = setTimeout(() => {
          blockEditor(`${licenseType}Limit`);
        }, 6e5);
        editor.on("destroy", () => {
          clearTimeout(timerId);
        });
      }
      if (licensePayload.usageEndpoint) {
        editor.once("ready", () => {
          const request = {
            requestId: uid(),
            requestTime: Math.round(Date.now() / 1e3),
            license: licenseKey,
            editor: collectUsageData(editor)
          };
          editor._sendUsageRequest(licensePayload.usageEndpoint, request).then((response) => {
            const { status, message } = response;
            if (message) {
              console.warn(message);
            }
            if (status != "ok") {
              blockEditor("usageLimit");
            }
          }, () => {
            logError("license-key-validation-endpoint-not-reachable", { url: licensePayload.usageEndpoint });
          });
        }, { priority: "high" });
      }
    }
  }
  /**
   * Defines whether the editor is in the read-only mode.
   *
   * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
   * to modify the document by using them. Also, the editable element(s) become non-editable.
   *
   * In order to make the editor read-only, you need to call the {@link #enableReadOnlyMode} method:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'feature-id' );
   * ```
   *
   * Later, to turn off the read-only mode, call {@link #disableReadOnlyMode}:
   *
   * ```ts
   * editor.disableReadOnlyMode( 'feature-id' );
   * ```
   *
   * @readonly
   * @observable
   */
  get isReadOnly() {
    return this._readOnlyLocks.size > 0;
  }
  set isReadOnly(value) {
    throw new CKEditorError("editor-isreadonly-has-no-setter");
  }
  /**
   * Turns on the read-only mode in the editor.
   *
   * Editor can be switched to or out of the read-only mode by many features, under various circumstances. The editor supports locking
   * mechanism for the read-only mode. It enables easy control over the read-only mode when many features wants to turn it on or off at
   * the same time, without conflicting with each other. It guarantees that you will not make the editor editable accidentally (which
   * could lead to errors).
   *
   * Each read-only mode request is identified by a unique id (also called "lock"). If multiple plugins requested to turn on the
   * read-only mode, then, the editor will become editable only after all these plugins turn the read-only mode off (using the same ids).
   *
   * Note, that you cannot force the editor to disable the read-only mode if other plugins set it.
   *
   * After the first `enableReadOnlyMode()` call, the {@link #isReadOnly `isReadOnly` property} will be set to `true`:
   *
   * ```ts
   * editor.isReadOnly; // `false`.
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `true`.
   * ```
   *
   * You can turn off the read-only mode ("clear the lock") using the {@link #disableReadOnlyMode `disableReadOnlyMode()`} method:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * // ...
   * editor.disableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `false`.
   * ```
   *
   * All "locks" need to be removed to enable editing:
   *
   * ```ts
   * editor.enableReadOnlyMode( 'my-feature-id' );
   * editor.enableReadOnlyMode( 'my-other-feature-id' );
   * // ...
   * editor.disableReadOnlyMode( 'my-feature-id' );
   * editor.isReadOnly; // `true`.
   * editor.disableReadOnlyMode( 'my-other-feature-id' );
   * editor.isReadOnly; // `false`.
   * ```
   *
   * @param lockId A unique ID for setting the editor to the read-only state.
   */
  enableReadOnlyMode(lockId) {
    if (typeof lockId !== "string" && typeof lockId !== "symbol") {
      throw new CKEditorError("editor-read-only-lock-id-invalid", null, { lockId });
    }
    if (this._readOnlyLocks.has(lockId)) {
      return;
    }
    this._readOnlyLocks.add(lockId);
    if (this._readOnlyLocks.size === 1) {
      this.fire("change:isReadOnly", "isReadOnly", true, false);
    }
  }
  /**
   * Removes the read-only lock from the editor with given lock ID.
   *
   * When no lock is present on the editor anymore, then the {@link #isReadOnly `isReadOnly` property} will be set to `false`.
   *
   * @param lockId The lock ID for setting the editor to the read-only state.
   */
  disableReadOnlyMode(lockId) {
    if (typeof lockId !== "string" && typeof lockId !== "symbol") {
      throw new CKEditorError("editor-read-only-lock-id-invalid", null, { lockId });
    }
    if (!this._readOnlyLocks.has(lockId)) {
      return;
    }
    this._readOnlyLocks.delete(lockId);
    if (this._readOnlyLocks.size === 0) {
      this.fire("change:isReadOnly", "isReadOnly", false, true);
    }
  }
  /**
   * Sets the data in the editor.
   *
   * ```ts
   * editor.setData( '<p>This is editor!</p>' );
   * ```
   *
   * If your editor implementation uses multiple roots, you should pass an object with keys corresponding
   * to the editor root names and values equal to the data that should be set in each root:
   *
   * ```ts
   * editor.setData( {
   *     header: '<p>Content for header part.</p>',
   *     content: '<p>Content for main part.</p>',
   *     footer: '<p>Content for footer part.</p>'
   * } );
   * ```
   *
   * By default the editor accepts HTML. This can be controlled by injecting a different data processor.
   * See the {@glink features/markdown Markdown output} guide for more details.
   *
   * @param data Input data.
   */
  setData(data) {
    this.data.set(data);
  }
  /**
   * Gets the data from the editor.
   *
   * ```ts
   * editor.getData(); // -> '<p>This is editor!</p>'
   * ```
   *
   * If your editor implementation uses multiple roots, you should pass root name as one of the options:
   *
   * ```ts
   * editor.getData( { rootName: 'header' } ); // -> '<p>Content for header part.</p>'
   * ```
   *
   * By default, the editor outputs HTML. This can be controlled by injecting a different data processor.
   * See the {@glink features/markdown Markdown output} guide for more details.
   *
   * A warning is logged when you try to retrieve data for a detached root, as most probably this is a mistake. A detached root should
   * be treated like it is removed, and you should not save its data. Note, that the detached root data is always an empty string.
   *
   * @param options Additional configuration for the retrieved data.
   * Editor features may introduce more configuration options that can be set through this parameter.
   * @param options.rootName Root name. Defaults to `'main'`.
   * @param options.trim Whether returned data should be trimmed. This option is set to `'empty'` by default,
   * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
   * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
   * @returns Output data.
   */
  getData(options) {
    return this.data.get(options);
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns A promise which resolves once the initialization is completed, providing an array of loaded plugins.
   */
  initPlugins() {
    const config = this.config;
    const plugins = config.get("plugins");
    const removePlugins = config.get("removePlugins") || [];
    const extraPlugins = config.get("extraPlugins") || [];
    const substitutePlugins = config.get("substitutePlugins") || [];
    return this.plugins.init(plugins.concat(extraPlugins), removePlugins, substitutePlugins);
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * **Note** The editor cannot be destroyed during the initialization phase so if it is called
   * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.
   *
   * @fires destroy
   * @returns A promise that resolves once the editor instance is fully destroyed.
   */
  destroy() {
    let readyPromise = Promise.resolve();
    if (this.state == "initializing") {
      readyPromise = new Promise((resolve) => this.once("ready", resolve));
    }
    return readyPromise.then(() => {
      this.fire("destroy");
      this.stopListening();
      this.commands.destroy();
    }).then(() => this.plugins.destroy()).then(() => {
      this.model.destroy();
      this.data.destroy();
      this.editing.destroy();
      this.keystrokes.destroy();
    }).then(() => this._context._removeEditor(this));
  }
  /**
   * Executes the specified command with given parameters.
   *
   * Shorthand for:
   *
   * ```ts
   * editor.commands.get( commandName ).execute( ... );
   * ```
   *
   * @param commandName The name of the command to execute.
   * @param commandParams Command parameters.
   * @returns The value returned by the {@link module:core/commandcollection~CommandCollection#execute `commands.execute()`}.
   */
  execute(commandName, ...commandParams) {
    try {
      return this.commands.execute(commandName, ...commandParams);
    } catch (err) {
      CKEditorError.rethrowUnexpectedError(err, this);
    }
  }
  /**
   * Focuses the editor.
   *
   * **Note** To explicitly focus the editing area of the editor, use the
   * {@link module:engine/view/view~View#focus `editor.editing.view.focus()`} method of the editing view.
   *
   * Check out the {@glink framework/deep-dive/ui/focus-tracking#focus-in-the-editor-ui Focus in the editor UI} section
   * of the {@glink framework/deep-dive/ui/focus-tracking Deep dive into focus tracking} guide to learn more.
   */
  focus() {
    this.editing.view.focus();
  }
  /* istanbul ignore next -- @preserve */
  /**
   * Creates and initializes a new editor instance.
   *
   * This is an abstract method. Every editor type needs to implement its own initialization logic.
   *
   * See the `create()` methods of the existing editor types to learn how to use them:
   *
   * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}
   * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}
   * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
   * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}
   */
  static create(...args) {
    throw new Error("This is an abstract method.");
  }
  _showLicenseError(reason, pluginName) {
    setTimeout(() => {
      if (reason == "invalid") {
        throw new CKEditorError("invalid-license-key");
      }
      if (reason == "expired") {
        throw new CKEditorError("license-key-expired");
      }
      if (reason == "domainLimit") {
        throw new CKEditorError("license-key-domain-limit");
      }
      if (reason == "featureNotAllowed") {
        throw new CKEditorError("license-key-plugin-not-allowed", null, { pluginName });
      }
      if (reason == "evaluationLimit") {
        throw new CKEditorError("license-key-evaluation-limit");
      }
      if (reason == "trialLimit") {
        throw new CKEditorError("license-key-trial-limit");
      }
      if (reason == "developmentLimit") {
        throw new CKEditorError("license-key-development-limit");
      }
      if (reason == "usageLimit") {
        throw new CKEditorError("license-key-usage-limit");
      }
      if (reason == "distributionChannel") {
        throw new CKEditorError("license-key-invalid-distribution-channel");
      }
      const unreachable = reason;
    }, 0);
    this._showLicenseError = () => {
    };
  }
  /**
   * This part of the code is _not_ executed in installations under the GPL license (with `config.licenseKey = 'GPL'`).
   *
   * It is only executed when a specific license key is provided. If you are uncertain whether
   * this applies to your installation, please contact our support team.
   */
  async _sendUsageRequest(endpoint, request) {
    const headers = new Headers({ "Content-Type": "application/json" });
    const response = await fetch(new URL(endpoint), {
      method: "POST",
      headers,
      body: JSON.stringify(request)
    });
    if (!response.ok) {
      throw new Error(`HTTP Response: ${response.status}`);
    }
    return response.json();
  }
};
Editor.Context = Context;
Editor.EditorWatchdog = EditorWatchdog;
Editor.ContextWatchdog = ContextWatchdog;
var editor_default = Editor;
function collectUsageData(editor) {
  const collectedData = getEditorUsageData(editor);
  function setUsageData(path, value) {
    if (get_default(collectedData, path) !== void 0) {
      throw new CKEditorError("editor-usage-data-path-already-set", { path });
    }
    set_default(collectedData, path, value);
  }
  editor.fire("collectUsageData", {
    setUsageData
  });
  return collectedData;
}

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/attachtoform.js
init_lodash();
function attachToForm(editor) {
  if (!isFunction_default(editor.updateSourceElement)) {
    throw new CKEditorError("attachtoform-missing-elementapi-interface", editor);
  }
  const sourceElement = editor.sourceElement;
  if (isTextArea(sourceElement) && sourceElement.form) {
    let originalSubmit;
    const form = sourceElement.form;
    const onSubmit = () => editor.updateSourceElement();
    if (isFunction_default(form.submit)) {
      originalSubmit = form.submit;
      form.submit = () => {
        onSubmit();
        originalSubmit.apply(form);
      };
    }
    form.addEventListener("submit", onSubmit);
    editor.on("destroy", () => {
      form.removeEventListener("submit", onSubmit);
      if (originalSubmit) {
        form.submit = originalSubmit;
      }
    });
  }
}
function isTextArea(sourceElement) {
  return !!sourceElement && sourceElement.tagName.toLowerCase() === "textarea";
}

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/dataapimixin.js
function DataApiMixin(base) {
  return base;
}

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/elementapimixin.js
function ElementApiMixin(base) {
  class Mixin extends base {
    updateSourceElement(data) {
      if (!this.sourceElement) {
        throw new CKEditorError("editor-missing-sourceelement", this);
      }
      const shouldUpdateSourceElement = this.config.get("updateSourceElementOnDestroy");
      const isSourceElementTextArea = this.sourceElement instanceof HTMLTextAreaElement;
      if (!shouldUpdateSourceElement && !isSourceElementTextArea) {
        setDataInElement(this.sourceElement, "");
        return;
      }
      const dataToSet = typeof data === "string" ? data : this.data.get();
      setDataInElement(this.sourceElement, dataToSet);
    }
  }
  return Mixin;
}
ElementApiMixin.updateSourceElement = ElementApiMixin(Object).prototype.updateSourceElement;

// node_modules/@ckeditor/ckeditor5-core/src/editor/utils/securesourceelement.js
function secureSourceElement(editor, sourceElement) {
  if (sourceElement.ckeditorInstance) {
    throw new CKEditorError("editor-source-element-already-used", editor);
  }
  sourceElement.ckeditorInstance = editor;
  editor.once("destroy", () => {
    delete sourceElement.ckeditorInstance;
  });
}

// node_modules/@ckeditor/ckeditor5-core/src/pendingactions.js
var PendingActions = class extends ContextPlugin {
  /**
   * @inheritDoc
   */
  static get pluginName() {
    return "PendingActions";
  }
  /**
   * @inheritDoc
   */
  static get isOfficialPlugin() {
    return true;
  }
  /**
   * @inheritDoc
   */
  init() {
    this.set("hasAny", false);
    this._actions = new Collection({ idProperty: "_id" });
    this._actions.delegate("add", "remove").to(this);
  }
  /**
   * Adds an action to the list of pending actions.
   *
   * This method returns an action object with an observable message property.
   * The action object can be later used in the {@link #remove} method. It also allows you to change the message.
   *
   * @param message The action message.
   * @returns An observable object that represents a pending action.
   */
  add(message) {
    if (typeof message !== "string") {
      throw new CKEditorError("pendingactions-add-invalid-message", this);
    }
    const action = new (ObservableMixin())();
    action.set("message", message);
    this._actions.add(action);
    this.hasAny = true;
    return action;
  }
  /**
   * Removes an action from the list of pending actions.
   *
   * @param action An action object.
   */
  remove(action) {
    this._actions.remove(action);
    this.hasAny = !!this._actions.length;
  }
  /**
   * Returns the first action from the list or null if the list is empty
   *
   * @returns The pending action object.
   */
  get first() {
    return this._actions.get(0);
  }
  /**
   * Iterable interface.
   */
  [Symbol.iterator]() {
    return this._actions[Symbol.iterator]();
  }
};

// node_modules/@ckeditor/ckeditor5-core/src/index.js
import cancel from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/cancel.svg";
import caption from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/caption.svg";
import check from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/check.svg";
import cog from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/cog.svg";
import colorPalette from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/color-palette.svg";
import eraser from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/eraser.svg";
import history from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/history.svg";
import lowVision from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/low-vision.svg";
import textAlternative from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/text-alternative.svg";
import loupe from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/loupe.svg";
import previousArrow from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/previous-arrow.svg";
import nextArrow from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/next-arrow.svg";
import image from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/image.svg";
import imageUpload from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/image-upload.svg";
import imageAssetManager from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/image-asset-manager.svg";
import imageUrl from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/image-url.svg";
import alignBottom from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-bottom.svg";
import alignMiddle from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-middle.svg";
import alignTop from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-top.svg";
import alignLeft from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-left.svg";
import alignCenter from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-center.svg";
import alignRight from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-right.svg";
import alignJustify from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/align-justify.svg";
import objectBlockLeft from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-left.svg";
import objectCenter from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-center.svg";
import objectBlockRight from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-right.svg";
import objectFullWidth from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-full-width.svg";
import objectInline from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-inline.svg";
import objectLeft from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-inline-left.svg";
import objectRight from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-inline-right.svg";
import objectSizeFull from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-full.svg";
import objectSizeCustom from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-custom.svg";
import objectSizeLarge from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-large.svg";
import objectSizeSmall from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-small.svg";
import objectSizeMedium from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/object-size-medium.svg";
import pencil from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/pencil.svg";
import pilcrow from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/pilcrow.svg";
import quote from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/quote.svg";
import threeVerticalDots from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/three-vertical-dots.svg";
import dragIndicator from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/drag-indicator.svg";
import bold from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/bold.svg";
import paragraph from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/paragraph.svg";
import plus from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/plus.svg";
import text from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/text.svg";
import importExport from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/importexport.svg";
import redo from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/redo.svg";
import undo from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/undo.svg";
import bulletedList from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/bulletedlist.svg";
import numberedList from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/numberedlist.svg";
import todoList from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/todolist.svg";
import codeBlock from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/codeblock.svg";
import browseFiles from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/browse-files.svg";
import heading1 from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading1.svg";
import heading2 from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading2.svg";
import heading3 from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading3.svg";
import heading4 from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading4.svg";
import heading5 from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading5.svg";
import heading6 from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/heading6.svg";
import horizontalLine from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/horizontalline.svg";
import html from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/html.svg";
import indent from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/indent.svg";
import outdent from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/outdent.svg";
import table from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/table.svg";
import source from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/source.svg";
import remove from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/remove.svg";
import bookmark from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/bookmark.svg";
import bookmarkInline from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/bookmark_inline.svg";
import emoji from "/Users/Bepositive/Desktop/beposoft-front-end-main/node_modules/@ckeditor/ckeditor5-core/theme/icons/emoji.svg";
var icons = {
  bold,
  cancel,
  caption,
  check,
  cog,
  colorPalette,
  eraser,
  history,
  image,
  imageUpload,
  imageAssetManager,
  imageUrl,
  lowVision,
  textAlternative,
  loupe,
  previousArrow,
  nextArrow,
  importExport,
  paragraph,
  plus,
  text,
  alignBottom,
  alignMiddle,
  alignTop,
  alignLeft,
  alignCenter,
  alignRight,
  alignJustify,
  objectLeft,
  objectCenter,
  objectRight,
  objectFullWidth,
  objectInline,
  objectBlockLeft,
  objectBlockRight,
  objectSizeCustom,
  objectSizeFull,
  objectSizeLarge,
  objectSizeSmall,
  objectSizeMedium,
  pencil,
  pilcrow,
  quote,
  threeVerticalDots,
  dragIndicator,
  redo,
  undo,
  bulletedList,
  numberedList,
  todoList,
  codeBlock,
  browseFiles,
  heading1,
  heading2,
  heading3,
  heading4,
  heading5,
  heading6,
  horizontalLine,
  html,
  indent,
  outdent,
  table,
  source,
  remove,
  bookmark,
  bookmarkInline,
  emoji
};
export {
  Command,
  Context,
  ContextPlugin,
  DataApiMixin,
  editor_default as Editor,
  ElementApiMixin,
  MultiCommand,
  PendingActions,
  Plugin,
  attachToForm,
  icons,
  secureSourceElement
};
/*! Bundled license information:

@ckeditor/ckeditor5-core/src/plugin.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/command.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/multicommand.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/plugincollection.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/context.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/contextplugin.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/commandcollection.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/editingkeystrokehandler.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/accessibility.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/editor/utils/editorusagedata.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/editor/editor.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)
  (* istanbul ignore next -- @preserve *)

@ckeditor/ckeditor5-core/src/editor/utils/attachtoform.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/editor/utils/dataapimixin.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/editor/utils/elementapimixin.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/editor/utils/securesourceelement.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/pendingactions.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/augmentation.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)

@ckeditor/ckeditor5-core/src/index.js:
  (**
   * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-core.js.map
